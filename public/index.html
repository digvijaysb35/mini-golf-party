<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mini Golf V3.0</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Titan+One&display=swap');
        
        body { margin: 0; background: #111; overflow: hidden; font-family: 'Titan One', cursive; touch-action: none; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; z-index: 10; }
        
        .panel { background: #fff; color: #2ecc71; padding: 8px 20px; border-radius: 30px; margin: 15px; text-align: center; box-shadow: 0 4px 0 #bdc3c7; border: 2px solid #2ecc71; }
        #top-bar { display: flex; justify-content: space-between; width: 100%; box-sizing: border-box; }
        
        #turn-indicator { font-size: 2rem; color: #f1c40f; text-shadow: 3px 3px 0 #000; -webkit-text-stroke: 1px black; transition: all 0.3s; }
        
        /* LOBBY */
        #lobby { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #27ae60; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; }
        
        input, select, button { padding: 15px; margin: 8px; font-size: 1.1rem; border-radius: 12px; border: none; width: 85%; max-width: 320px; font-family: 'Titan One', cursive; text-align: center; }
        input { background: #ecf0f1; color: #2c3e50; }
        button { background: #f1c40f; color: #d35400; cursor: pointer; box-shadow: 0 5px 0 #c0392b; transition: transform 0.1s; }
        button:active { transform: translateY(5px); box-shadow: none; }
        
        .hidden { display: none !important; }
        canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>

    <div id="lobby">
        <h1 style="color:white; font-size: 3rem; text-shadow: 4px 4px 0 rgba(0,0,0,0.2);">MINI GOLF</h1>
        <input type="text" id="pName" placeholder="YOUR NAME">
        
        <div id="start-buttons" style="width:100%; display:flex; flex-direction:column; align-items:center;">
            <div style="margin: 10px; color:rgba(255,255,255,0.8);">--- CREATE ---</div>
            <select id="playerCount">
                <option value="2">2 Players</option>
                <option value="3">3 Players</option>
                <option value="4">4 Players</option>
            </select>
            <button onclick="createRoom()">CREATE PARTY</button>
            
            <div style="margin: 10px; color:rgba(255,255,255,0.8);">--- JOIN ---</div>
            <input type="text" id="rCode" placeholder="ROOM CODE" style="text-transform:uppercase;">
            <button onclick="joinRoom()" style="background:#3498db; color:white; box-shadow: 0 5px 0 #2980b9;">JOIN PARTY</button>
        </div>

        <div id="waiting-area" class="hidden" style="text-align: center;">
            <h2 style="color:white;">ROOM CODE:<br><span id="room-display" style="font-size:3rem; color:#f1c40f;"></span></h2>
            <div id="player-list" style="margin: 20px 0;"></div>
            <div style="color:white; animation: pulse 1s infinite;">Waiting for friends...</div>
        </div>
    </div>

    <div id="ui-layer" class="hidden">
        <div id="top-bar">
            <div class="panel" id="round-display">ROUND 1</div>
            <div class="panel" id="score-display">PAR 3</div>
        </div>
        <div style="text-align: center; margin-bottom: 60px;">
            <div id="turn-indicator">WAITING...</div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const VW = 400; const VH = 800;
        let scale = 1, offsetX = 0, offsetY = 0;
        
        let myId = null, roomId = null, players = [], map = null, currentTurnId = null;
        let isMoving = false;
        let ball = { vx: 0, vy: 0 };
        let dragStart = null, dragCurrent = null;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            let scaleX = canvas.width / VW;
            let scaleY = canvas.height / VH;
            scale = Math.min(scaleX, scaleY);
            offsetX = (canvas.width - (VW * scale)) / 2;
            offsetY = (canvas.height - (VH * scale)) / 2;
        }
        window.addEventListener('resize', resize);
        resize();

        function createRoom() {
            const name = document.getElementById('pName').value.trim();
            if(!name) return alert("Name required!");
            const count = document.getElementById('playerCount').value;
            socket.emit('create_room', { maxPlayers: count });
            waitForLobby();
        }

        function joinRoom() {
            const name = document.getElementById('pName').value.trim();
            const code = document.getElementById('rCode').value.toUpperCase();
            if(!name || !code) return alert("Enter Name & Code!");
            roomId = code;
            socket.emit('join_room', { roomId: code, name: name });
            waitForLobby();
        }

        function waitForLobby() {
            document.getElementById('start-buttons').classList.add('hidden');
            document.getElementById('waiting-area').classList.remove('hidden');
            document.getElementById('pName').blur();
        }

        socket.on('room_created', (id) => { 
            roomId = id; 
            document.getElementById('room-display').innerText = id;
            const name = document.getElementById('pName').value;
            socket.emit('join_room', { roomId: id, name: name });
        });
        
        socket.on('update_lobby', (pList) => {
            document.getElementById('player-list').innerHTML = pList.map(p => `
                <div style="background:white; color:${p.color}; padding:10px; margin:5px; border-radius:10px; display:inline-block; font-weight:bold;">
                    ${p.name}
                </div>`).join('');
        });

        socket.on('game_start', (data) => {
            document.getElementById('lobby').classList.add('hidden');
            document.getElementById('ui-layer').classList.remove('hidden');
            myId = socket.id;
            map = data.map;
            players = data.players;
            currentTurnId = data.turnId;
            updateTurnUI();
            requestAnimationFrame(loop);
        });

        socket.on('player_shot', (data) => {
            const p = players.find(pl => pl.id === data.id);
            if(p) { p.vx = data.vx; p.vy = data.vy; if(data.id === myId) { ball.vx = data.vx; ball.vy = data.vy; } isMoving = true; }
        });

        socket.on('change_turn', (data) => { currentTurnId = data.turnId; players = data.players; updateTurnUI(); });
        
        socket.on('next_round', (data) => {
            map = data.map; players = data.players; currentTurnId = data.turnId;
            document.getElementById('round-display').innerText = "ROUND " + map.round;
            isMoving = false;
            updateTurnUI();
        });

        socket.on('msg', (msg) => { alert(msg); });

        function updateTurnUI() {
            const div = document.getElementById('turn-indicator');
            if(currentTurnId === myId) {
                div.innerText = "⭐ YOUR TURN ⭐"; div.style.color = "#f1c40f"; div.style.transform = "scale(1.2)";
            } else {
                const p = players.find(pl => pl.id === currentTurnId);
                div.innerText = `WAITING FOR ${p ? p.name.toUpperCase() : '...'}`; div.style.color = "white"; div.style.transform = "scale(1)";
            }
        }

        // INPUT
        canvas.addEventListener('touchstart', (e) => handleStart(e.touches[0]));
        canvas.addEventListener('mousedown', (e) => handleStart(e));

        function handleStart(e) {
            if(isMoving || currentTurnId !== myId) return;
            const me = players.find(p => p.id === myId);
            if(!me || me.finished) return;
            const cx = (e.clientX - offsetX) / scale;
            const cy = (e.clientY - offsetY) / scale;
            if(Math.hypot(cx - me.x, cy - me.y) < 100) { dragStart = {x:cx, y:cy}; dragCurrent = {x:cx, y:cy}; }
        }

        window.addEventListener('touchmove', (e) => { if(dragStart) dragCurrent = { x:(e.touches[0].clientX-offsetX)/scale, y:(e.touches[0].clientY-offsetY)/scale }; });
        window.addEventListener('mousemove', (e) => { if(dragStart) dragCurrent = { x:(e.clientX-offsetX)/scale, y:(e.clientY-offsetY)/scale }; });

        window.addEventListener('touchend', handleEnd);
        window.addEventListener('mouseup', handleEnd);

        function handleEnd() {
            if(!dragStart) return;
            let dx = dragStart.x - dragCurrent.x; let dy = dragStart.y - dragCurrent.y;
            let power = Math.hypot(dx, dy);
            if(power > 150) { let r = 150/power; dx*=r; dy*=r; } // Cap power
            
            if(power > 10) {
                socket.emit('shoot', { roomId, vx: dx*0.15, vy: dy*0.15 });
            }
            dragStart = null;
        }

        function update() {
            if(!map) return;
            let moving = 0;
            players.forEach(p => {
                if(p.finished) { p.x = -500; return; }
                if(Math.abs(p.vx) > 0.05 || Math.abs(p.vy) > 0.05) {
                    p.x += p.vx; p.y += p.vy;
                    p.vx *= 0.96; p.vy *= 0.96;
                    moving++;
                    
                    // Collision
                    if(p.x < 10 || p.x > VW-10) { p.vx *= -1; p.x = p.x < 10 ? 12 : VW-12; }
                    if(p.y < 10 || p.y > VH-10) { p.vy *= -1; p.y = p.y < 10 ? 12 : VH-12; }
                    
                    map.walls.forEach(w => {
                        if(p.x > w.x-10 && p.x < w.x+w.w+10 && p.y > w.y-10 && p.y < w.y+w.h+10) {
                             // Simple bounding box bounce
                             let cx = w.x + w.w/2; let cy = w.y + w.h/2;
                             if (Math.abs(p.x - cx) > Math.abs(p.y - cy) * (w.w/w.h)) { p.vx *= -1; } else { p.vy *= -1; }
                        }
                    });

                    if(Math.hypot(p.x - map.hole.x, p.y - map.hole.y) < map.hole.radius) {
                        p.vx=0; p.vy=0; p.finished=true;
                        if(p.id === myId) { socket.emit('hole_in', {roomId}); socket.emit('turn_complete', {roomId, x:p.x, y:p.y}); }
                    }
                } else { p.vx=0; p.vy=0; }
            });

            if(isMoving && moving === 0) {
                isMoving = false;
                if(currentTurnId === myId) {
                    const me = players.find(p => p.id === myId);
                    socket.emit('turn_complete', { roomId, x: me.x, y: me.y });
                }
            }
        }

        function draw() {
            ctx.fillStyle = '#111'; ctx.fillRect(0,0,canvas.width, canvas.height);
            if(!map) return;
            
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            // GRASS
            ctx.fillStyle = '#58B947'; 
            ctx.fillRect(0, 0, VW, VH);
            
            // PATTERN (ARROWS)
            ctx.fillStyle = 'rgba(0,0,0,0.05)';
            for(let y=0; y<VH; y+=40) {
                for(let x=0; x<VW; x+=40) {
                    if((x+y)%80 === 0) {
                        ctx.beginPath();
                        ctx.moveTo(x, y); ctx.lineTo(x+10, y+10); ctx.lineTo(x+20, y);
                        ctx.lineTo(x+10, y-10); ctx.fill();
                    }
                }
            }

            // WALLS
            map.walls.forEach(w => {
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(w.x+4, w.y+6, w.w, w.h);
                // Body
                ctx.fillStyle = '#e67e22'; ctx.fillRect(w.x, w.y, w.w, w.h); // Orange
                // Top Light
                ctx.fillStyle = '#f39c12'; ctx.fillRect(w.x, w.y, w.w, w.h-5);
            });

            // HOLE
            ctx.fillStyle = '#2c3e50'; ctx.beginPath(); ctx.arc(map.hole.x, map.hole.y, 18, 0, Math.PI*2); ctx.fill();
            
            // PLAYERS
            players.forEach(p => {
                if(p.finished) return;
                ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.beginPath(); ctx.arc(p.x+2, p.y+4, 9, 0, Math.PI*2); ctx.fill(); // Shadow
                ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 9, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.beginPath(); ctx.arc(p.x-3, p.y-3, 3, 0, Math.PI*2); ctx.fill();
                
                if(p.id === currentTurnId) {
                    ctx.strokeStyle = 'white'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(p.x, p.y, 14, 0, Math.PI*2); ctx.stroke();
                }
            });

            // AIM LINE
            if(dragStart && currentTurnId === myId) {
                const me = players.find(p => p.id === myId);
                let dx = dragStart.x - dragCurrent.x; let dy = dragStart.y - dragCurrent.y;
                
                // Pull Line
                ctx.beginPath(); ctx.strokeStyle = 'white'; ctx.lineWidth=4; 
                ctx.moveTo(me.x, me.y); ctx.lineTo(me.x-dx, me.y-dy); ctx.stroke();
                
                // Trajectory (Dashed)
                ctx.beginPath(); ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.setLineDash([5,5]);
                ctx.moveTo(me.x, me.y); ctx.lineTo(me.x + dx*3, me.y + dy*3); ctx.stroke(); ctx.setLineDash([]);
            }

            ctx.restore();
        }

        function loop() { update(); draw(); requestAnimationFrame(loop); }
    </script>
</body>
</html>
